{"id":"node_modules/rxjs/src/internal/Subscriber.ts","dependencies":[{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\tsconfig.json","includedInParent":true,"mtime":1658249596656},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\package.json","includedInParent":true,"mtime":1658249837276},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1658249596644},{"name":"./util/isFunction","loc":{"line":4,"column":29,"index":188},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\isFunction.ts"},{"name":"./Subscription","loc":{"line":5,"column":31,"index":242},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscription.ts"},{"name":"./config","loc":{"line":6,"column":25,"index":287},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\config.ts"},{"name":"./util/reportUnhandledError","loc":{"line":7,"column":39,"index":340},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\reportUnhandledError.ts"},{"name":"./util/noop","loc":{"line":8,"column":23,"index":396},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\noop.ts"},{"name":"./NotificationFactories","loc":{"line":9,"column":40,"index":453},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\NotificationFactories.ts"},{"name":"./scheduler/timeoutProvider","loc":{"line":10,"column":34,"index":516},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\scheduler\\timeoutProvider.ts"},{"name":"./util/errorContext","loc":{"line":11,"column":31,"index":580},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscriber.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\errorContext.ts"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;\r\nconst isFunction_1 = require(\"./util/isFunction\");\r\nconst Subscription_1 = require(\"./Subscription\");\r\nconst config_1 = require(\"./config\");\r\nconst reportUnhandledError_1 = require(\"./util/reportUnhandledError\");\r\nconst noop_1 = require(\"./util/noop\");\r\nconst NotificationFactories_1 = require(\"./NotificationFactories\");\r\nconst timeoutProvider_1 = require(\"./scheduler/timeoutProvider\");\r\nconst errorContext_1 = require(\"./util/errorContext\");\r\nclass Subscriber extends Subscription_1.Subscription {\r\n    static create(next, error, complete) {\r\n        return new SafeSubscriber(next, error, complete);\r\n    }\r\n    isStopped = false;\r\n    destination;\r\n    constructor(destination) {\r\n        super();\r\n        if (destination) {\r\n            this.destination = destination;\r\n            if ((0, Subscription_1.isSubscription)(destination)) {\r\n                destination.add(this);\r\n            }\r\n        }\r\n        else {\r\n            this.destination = exports.EMPTY_OBSERVER;\r\n        }\r\n    }\r\n    next(value) {\r\n        if (this.isStopped) {\r\n            handleStoppedNotification((0, NotificationFactories_1.nextNotification)(value), this);\r\n        }\r\n        else {\r\n            this._next(value);\r\n        }\r\n    }\r\n    error(err) {\r\n        if (this.isStopped) {\r\n            handleStoppedNotification((0, NotificationFactories_1.errorNotification)(err), this);\r\n        }\r\n        else {\r\n            this.isStopped = true;\r\n            this._error(err);\r\n        }\r\n    }\r\n    complete() {\r\n        if (this.isStopped) {\r\n            handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);\r\n        }\r\n        else {\r\n            this.isStopped = true;\r\n            this._complete();\r\n        }\r\n    }\r\n    unsubscribe() {\r\n        if (!this.closed) {\r\n            this.isStopped = true;\r\n            super.unsubscribe();\r\n            this.destination = null;\r\n        }\r\n    }\r\n    _next(value) {\r\n        this.destination.next(value);\r\n    }\r\n    _error(err) {\r\n        try {\r\n            this.destination.error(err);\r\n        }\r\n        finally {\r\n            this.unsubscribe();\r\n        }\r\n    }\r\n    _complete() {\r\n        try {\r\n            this.destination.complete();\r\n        }\r\n        finally {\r\n            this.unsubscribe();\r\n        }\r\n    }\r\n}\r\nexports.Subscriber = Subscriber;\r\nconst _bind = Function.prototype.bind;\r\nfunction bind(fn, thisArg) {\r\n    return _bind.call(fn, thisArg);\r\n}\r\nclass ConsumerObserver {\r\n    partialObserver;\r\n    constructor(partialObserver) {\r\n        this.partialObserver = partialObserver;\r\n    }\r\n    next(value) {\r\n        const { partialObserver } = this;\r\n        if (partialObserver.next) {\r\n            try {\r\n                partialObserver.next(value);\r\n            }\r\n            catch (error) {\r\n                handleUnhandledError(error);\r\n            }\r\n        }\r\n    }\r\n    error(err) {\r\n        const { partialObserver } = this;\r\n        if (partialObserver.error) {\r\n            try {\r\n                partialObserver.error(err);\r\n            }\r\n            catch (error) {\r\n                handleUnhandledError(error);\r\n            }\r\n        }\r\n        else {\r\n            handleUnhandledError(err);\r\n        }\r\n    }\r\n    complete() {\r\n        const { partialObserver } = this;\r\n        if (partialObserver.complete) {\r\n            try {\r\n                partialObserver.complete();\r\n            }\r\n            catch (error) {\r\n                handleUnhandledError(error);\r\n            }\r\n        }\r\n    }\r\n}\r\nclass SafeSubscriber extends Subscriber {\r\n    constructor(observerOrNext, error, complete) {\r\n        super();\r\n        let partialObserver;\r\n        if ((0, isFunction_1.isFunction)(observerOrNext) || !observerOrNext) {\r\n            partialObserver = {\r\n                next: (observerOrNext ?? undefined),\r\n                error: error ?? undefined,\r\n                complete: complete ?? undefined,\r\n            };\r\n        }\r\n        else {\r\n            let context;\r\n            if (this && config_1.config.useDeprecatedNextContext) {\r\n                context = Object.create(observerOrNext);\r\n                context.unsubscribe = () => this.unsubscribe();\r\n                partialObserver = {\r\n                    next: observerOrNext.next && bind(observerOrNext.next, context),\r\n                    error: observerOrNext.error && bind(observerOrNext.error, context),\r\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context),\r\n                };\r\n            }\r\n            else {\r\n                partialObserver = observerOrNext;\r\n            }\r\n        }\r\n        this.destination = new ConsumerObserver(partialObserver);\r\n    }\r\n}\r\nexports.SafeSubscriber = SafeSubscriber;\r\nfunction handleUnhandledError(error) {\r\n    if (config_1.config.useDeprecatedSynchronousErrorHandling) {\r\n        (0, errorContext_1.captureError)(error);\r\n    }\r\n    else {\r\n        (0, reportUnhandledError_1.reportUnhandledError)(error);\r\n    }\r\n}\r\nfunction defaultErrorHandler(err) {\r\n    throw err;\r\n}\r\nfunction handleStoppedNotification(notification, subscriber) {\r\n    const { onStoppedNotification } = config_1.config;\r\n    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\r\n}\r\nexports.EMPTY_OBSERVER = {\r\n    closed: true,\r\n    next: noop_1.noop,\r\n    error: defaultErrorHandler,\r\n    complete: noop_1.noop,\r\n};\r\n"},"sourceMaps":{"js":{"version":3,"file":"Subscriber.js","sourceRoot":"","sources":["node_modules/rxjs/src/internal/Subscriber.ts"],"names":[],"mappings":"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","sourcesContent":["import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n"]}},"error":null,"hash":"ff51ac17c40e9d9f4fecd769226e105b","cacheData":{"env":{}}}