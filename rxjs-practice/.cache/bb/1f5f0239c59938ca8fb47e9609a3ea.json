{"id":"node_modules/rxjs/src/internal/operators/skipLast.ts","dependencies":[{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\tsconfig.json","includedInParent":true,"mtime":1658249596656},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\package.json","includedInParent":true,"mtime":1658249837276},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1658249596644},{"name":"../util/identity","loc":{"line":4,"column":27,"index":134},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\skipLast.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\identity.ts"},{"name":"../util/lift","loc":{"line":5,"column":23,"index":179},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\skipLast.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\lift.ts"},{"name":"./OperatorSubscriber","loc":{"line":6,"column":37,"index":234},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\skipLast.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\OperatorSubscriber.ts"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.skipLast = void 0;\r\nconst identity_1 = require(\"../util/identity\");\r\nconst lift_1 = require(\"../util/lift\");\r\nconst OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\r\nfunction skipLast(skipCount) {\r\n    return skipCount <= 0\r\n        ?\r\n            identity_1.identity\r\n        : (0, lift_1.operate)((source, subscriber) => {\r\n            let ring = new Array(skipCount);\r\n            let seen = 0;\r\n            source.subscribe((0, OperatorSubscriber_1.createOperatorSubscriber)(subscriber, (value) => {\r\n                const valueIndex = seen++;\r\n                if (valueIndex < skipCount) {\r\n                    ring[valueIndex] = value;\r\n                }\r\n                else {\r\n                    const index = valueIndex % skipCount;\r\n                    const oldValue = ring[index];\r\n                    ring[index] = value;\r\n                    subscriber.next(oldValue);\r\n                }\r\n            }));\r\n            return () => {\r\n                ring = null;\r\n            };\r\n        });\r\n}\r\nexports.skipLast = skipLast;\r\n"},"sourceMaps":{"js":{"version":3,"file":"skipLast.js","sourceRoot":"","sources":["node_modules/rxjs/src/internal/operators/skipLast.ts"],"names":[],"mappings":";;;AACA,+CAA4C;AAC5C,uCAAuC;AACvC,6DAAgE;AA4ChE,SAAgB,QAAQ,CAAI,SAAiB;IAC3C,OAAO,SAAS,IAAI,CAAC;QACnB,CAAC;YACC,mBAAQ;QACV,CAAC,CAAC,IAAA,cAAO,EAAC,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE;YAI7B,IAAI,IAAI,GAAQ,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;YAGrC,IAAI,IAAI,GAAG,CAAC,CAAC;YACb,MAAM,CAAC,SAAS,CACd,IAAA,6CAAwB,EAAC,UAAU,EAAE,CAAC,KAAK,EAAE,EAAE;gBAK7C,MAAM,UAAU,GAAG,IAAI,EAAE,CAAC;gBAC1B,IAAI,UAAU,GAAG,SAAS,EAAE;oBAI1B,IAAI,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC;iBAC1B;qBAAM;oBAIL,MAAM,KAAK,GAAG,UAAU,GAAG,SAAS,CAAC;oBAGrC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;oBAC7B,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;oBAKpB,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;iBAC3B;YACH,CAAC,CAAC,CACH,CAAC;YAEF,OAAO,GAAG,EAAE;gBAEV,IAAI,GAAG,IAAK,CAAC;YACf,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;AACT,CAAC;AA/CD,4BA+CC","sourcesContent":["import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Skip a specified number of values before the completion of an observable.\n *\n * ![](skipLast.png)\n *\n * Returns an observable that will emit values as soon as it can, given a number of\n * skipped values. For example, if you `skipLast(3)` on a source, when the source\n * emits its fourth value, the first value the source emitted will finally be emitted\n * from the returned observable, as it is no longer part of what needs to be skipped.\n *\n * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,\n * as each value is held in a buffer until enough values have been emitted that that\n * the buffered value may finally be sent to the consumer.\n *\n * After subscribing, unsubscribing will not result in the emission of the buffered\n * skipped values.\n *\n * ## Example\n *\n * Skip the last 2 values of an observable with many values\n *\n * ```ts\n * import { of, skipLast } from 'rxjs';\n *\n * const numbers = of(1, 2, 3, 4, 5);\n * const skipLastTwo = numbers.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * // (4 and 5 are skipped)\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @param skipCount Number of elements to skip from the end of the source Observable.\n * @return A function that returns an Observable that skips the last `count`\n * values emitted by the source Observable.\n */\nexport function skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T> {\n  return skipCount <= 0\n    ? // For skipCounts less than or equal to zero, we are just mirroring the source.\n      identity\n    : operate((source, subscriber) => {\n        // A ring buffer to hold the values while we wait to see\n        // if we can emit it or it's part of the \"skipped\" last values.\n        // Note that it is the _same size_ as the skip count.\n        let ring: T[] = new Array(skipCount);\n        // The number of values seen so far. This is used to get\n        // the index of the current value when it arrives.\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Get the index of the value we have right now\n            // relative to all other values we've seen, then\n            // increment `seen`. This ensures we've moved to\n            // the next slot in our ring buffer.\n            const valueIndex = seen++;\n            if (valueIndex < skipCount) {\n              // If we haven't seen enough values to fill our buffer yet,\n              // Then we aren't to a number of seen values where we can\n              // emit anything, so let's just start by filling the ring buffer.\n              ring[valueIndex] = value;\n            } else {\n              // We are traversing over the ring array in such\n              // a way that when we get to the end, we loop back\n              // and go to the start.\n              const index = valueIndex % skipCount;\n              // Pull the oldest value out so we can emit it,\n              // and stuff the new value in it's place.\n              const oldValue = ring[index];\n              ring[index] = value;\n              // Emit the old value. It is important that this happens\n              // after we swap the value in the buffer, if it happens\n              // before we swap the value in the buffer, then a synchronous\n              // source can get the buffer out of whack.\n              subscriber.next(oldValue);\n            }\n          })\n        );\n\n        return () => {\n          // Release our values in memory\n          ring = null!;\n        };\n      });\n}\n"]}},"error":null,"hash":"1d39d0592f946e8bf2ed6f41709d0a3e","cacheData":{"env":{}}}