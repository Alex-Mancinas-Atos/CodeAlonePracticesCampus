{"id":"node_modules/rxjs/src/internal/Notification.ts","dependencies":[{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\tsconfig.json","includedInParent":true,"mtime":1658249596656},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\package.json","includedInParent":true,"mtime":1658249837276},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1658249596644},{"name":"./observable/empty","loc":{"line":4,"column":24,"index":192},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Notification.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\observable\\empty.ts"},{"name":"./observable/of","loc":{"line":5,"column":21,"index":237},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Notification.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\observable\\of.ts"},{"name":"./observable/throwError","loc":{"line":6,"column":29,"index":287},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Notification.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\observable\\throwError.ts"},{"name":"./util/isFunction","loc":{"line":7,"column":29,"index":345},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Notification.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\isFunction.ts"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observeNotification = exports.Notification = exports.NotificationKind = void 0;\r\nconst empty_1 = require(\"./observable/empty\");\r\nconst of_1 = require(\"./observable/of\");\r\nconst throwError_1 = require(\"./observable/throwError\");\r\nconst isFunction_1 = require(\"./util/isFunction\");\r\nvar NotificationKind;\r\n(function (NotificationKind) {\r\n    NotificationKind[\"NEXT\"] = \"N\";\r\n    NotificationKind[\"ERROR\"] = \"E\";\r\n    NotificationKind[\"COMPLETE\"] = \"C\";\r\n})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));\r\nclass Notification {\r\n    kind;\r\n    value;\r\n    error;\r\n    hasValue;\r\n    constructor(kind, value, error) {\r\n        this.kind = kind;\r\n        this.value = value;\r\n        this.error = error;\r\n        this.hasValue = kind === 'N';\r\n    }\r\n    observe(observer) {\r\n        return observeNotification(this, observer);\r\n    }\r\n    do(nextHandler, errorHandler, completeHandler) {\r\n        const { kind, value, error } = this;\r\n        return kind === 'N' ? nextHandler?.(value) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\r\n    }\r\n    accept(nextOrObserver, error, complete) {\r\n        return (0, isFunction_1.isFunction)(nextOrObserver?.next)\r\n            ? this.observe(nextOrObserver)\r\n            : this.do(nextOrObserver, error, complete);\r\n    }\r\n    toObservable() {\r\n        const { kind, value, error } = this;\r\n        const result = kind === 'N'\r\n            ?\r\n                (0, of_1.of)(value)\r\n            :\r\n                kind === 'E'\r\n                    ?\r\n                        (0, throwError_1.throwError)(() => error)\r\n                    :\r\n                        kind === 'C'\r\n                            ?\r\n                                empty_1.EMPTY\r\n                            :\r\n                                0;\r\n        if (!result) {\r\n            throw new TypeError(`Unexpected notification kind ${kind}`);\r\n        }\r\n        return result;\r\n    }\r\n    static completeNotification = new Notification('C');\r\n    static createNext(value) {\r\n        return new Notification('N', value);\r\n    }\r\n    static createError(err) {\r\n        return new Notification('E', undefined, err);\r\n    }\r\n    static createComplete() {\r\n        return Notification.completeNotification;\r\n    }\r\n}\r\nexports.Notification = Notification;\r\nfunction observeNotification(notification, observer) {\r\n    const { kind, value, error } = notification;\r\n    if (typeof kind !== 'string') {\r\n        throw new TypeError('Invalid notification, missing \"kind\"');\r\n    }\r\n    kind === 'N' ? observer.next?.(value) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\r\n}\r\nexports.observeNotification = observeNotification;\r\n"},"sourceMaps":{"js":{"version":3,"file":"Notification.js","sourceRoot":"","sources":["node_modules/rxjs/src/internal/Notification.ts"],"names":[],"mappings":"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","sourcesContent":["import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n"]}},"error":null,"hash":"53e92e99e50b11b0a98ff1e303c09ec9","cacheData":{"env":{}}}