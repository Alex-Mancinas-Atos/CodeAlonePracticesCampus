{"id":"node_modules/rxjs/src/internal/operators/bufferTime.ts","dependencies":[{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\tsconfig.json","includedInParent":true,"mtime":1658249596656},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\package.json","includedInParent":true,"mtime":1658249837276},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1658249596644},{"name":"../Subscription","loc":{"line":4,"column":31,"index":140},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\Subscription.ts"},{"name":"../util/lift","loc":{"line":5,"column":23,"index":184},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\lift.ts"},{"name":"./OperatorSubscriber","loc":{"line":6,"column":37,"index":239},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\OperatorSubscriber.ts"},{"name":"../util/arrRemove","loc":{"line":7,"column":28,"index":293},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\arrRemove.ts"},{"name":"../scheduler/async","loc":{"line":8,"column":24,"index":340},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\scheduler\\async.ts"},{"name":"../util/args","loc":{"line":9,"column":23,"index":387},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\args.ts"},{"name":"../util/executeSchedule","loc":{"line":10,"column":34,"index":439},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\bufferTime.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\executeSchedule.ts"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.bufferTime = void 0;\r\nconst Subscription_1 = require(\"../Subscription\");\r\nconst lift_1 = require(\"../util/lift\");\r\nconst OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\r\nconst arrRemove_1 = require(\"../util/arrRemove\");\r\nconst async_1 = require(\"../scheduler/async\");\r\nconst args_1 = require(\"../util/args\");\r\nconst executeSchedule_1 = require(\"../util/executeSchedule\");\r\nfunction bufferTime(bufferTimeSpan, ...otherArgs) {\r\n    const scheduler = (0, args_1.popScheduler)(otherArgs) ?? async_1.asyncScheduler;\r\n    const bufferCreationInterval = otherArgs[0] ?? null;\r\n    const maxBufferSize = otherArgs[1] || Infinity;\r\n    return (0, lift_1.operate)((source, subscriber) => {\r\n        let bufferRecords = [];\r\n        let restartOnEmit = false;\r\n        const emit = (record) => {\r\n            const { buffer, subs } = record;\r\n            subs.unsubscribe();\r\n            (0, arrRemove_1.arrRemove)(bufferRecords, record);\r\n            subscriber.next(buffer);\r\n            restartOnEmit && startBuffer();\r\n        };\r\n        const startBuffer = () => {\r\n            if (bufferRecords) {\r\n                const subs = new Subscription_1.Subscription();\r\n                subscriber.add(subs);\r\n                const buffer = [];\r\n                const record = {\r\n                    buffer,\r\n                    subs,\r\n                };\r\n                bufferRecords.push(record);\r\n                (0, executeSchedule_1.executeSchedule)(subs, scheduler, () => emit(record), bufferTimeSpan);\r\n            }\r\n        };\r\n        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\r\n            (0, executeSchedule_1.executeSchedule)(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\r\n        }\r\n        else {\r\n            restartOnEmit = true;\r\n        }\r\n        startBuffer();\r\n        const bufferTimeSubscriber = (0, OperatorSubscriber_1.createOperatorSubscriber)(subscriber, (value) => {\r\n            const recordsCopy = bufferRecords.slice();\r\n            for (const record of recordsCopy) {\r\n                const { buffer } = record;\r\n                buffer.push(value);\r\n                maxBufferSize <= buffer.length && emit(record);\r\n            }\r\n        }, () => {\r\n            while (bufferRecords?.length) {\r\n                subscriber.next(bufferRecords.shift().buffer);\r\n            }\r\n            bufferTimeSubscriber?.unsubscribe();\r\n            subscriber.complete();\r\n            subscriber.unsubscribe();\r\n        }, undefined, () => (bufferRecords = null));\r\n        source.subscribe(bufferTimeSubscriber);\r\n    });\r\n}\r\nexports.bufferTime = bufferTime;\r\n"},"sourceMaps":{"js":{"version":3,"file":"bufferTime.js","sourceRoot":"","sources":["node_modules/rxjs/src/internal/operators/bufferTime.ts"],"names":[],"mappings":";;;AAAA,kDAA+C;AAE/C,uCAAuC;AACvC,6DAAgE;AAChE,iDAA8C;AAC9C,8CAAoD;AACpD,uCAA4C;AAC5C,6DAA0D;AAsE1D,SAAgB,UAAU,CAAI,cAAsB,EAAE,GAAG,SAAgB;IACvE,MAAM,SAAS,GAAG,IAAA,mBAAY,EAAC,SAAS,CAAC,IAAI,sBAAc,CAAC;IAC5D,MAAM,sBAAsB,GAAI,SAAS,CAAC,CAAC,CAAY,IAAI,IAAI,CAAC;IAChE,MAAM,aAAa,GAAI,SAAS,CAAC,CAAC,CAAY,IAAI,QAAQ,CAAC;IAE3D,OAAO,IAAA,cAAO,EAAC,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE;QAEpC,IAAI,aAAa,GAAiD,EAAE,CAAC;QAGrE,IAAI,aAAa,GAAG,KAAK,CAAC;QAQ1B,MAAM,IAAI,GAAG,CAAC,MAA2C,EAAE,EAAE;YAC3D,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;YAChC,IAAI,CAAC,WAAW,EAAE,CAAC;YACnB,IAAA,qBAAS,EAAC,aAAa,EAAE,MAAM,CAAC,CAAC;YACjC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACxB,aAAa,IAAI,WAAW,EAAE,CAAC;QACjC,CAAC,CAAC;QAOF,MAAM,WAAW,GAAG,GAAG,EAAE;YACvB,IAAI,aAAa,EAAE;gBACjB,MAAM,IAAI,GAAG,IAAI,2BAAY,EAAE,CAAC;gBAChC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBACrB,MAAM,MAAM,GAAQ,EAAE,CAAC;gBACvB,MAAM,MAAM,GAAG;oBACb,MAAM;oBACN,IAAI;iBACL,CAAC;gBACF,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC3B,IAAA,iCAAe,EAAC,IAAI,EAAE,SAAS,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,cAAc,CAAC,CAAC;aACtE;QACH,CAAC,CAAC;QAEF,IAAI,sBAAsB,KAAK,IAAI,IAAI,sBAAsB,IAAI,CAAC,EAAE;YAIlE,IAAA,iCAAe,EAAC,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE,sBAAsB,EAAE,IAAI,CAAC,CAAC;SACnF;aAAM;YACL,aAAa,GAAG,IAAI,CAAC;SACtB;QAED,WAAW,EAAE,CAAC;QAEd,MAAM,oBAAoB,GAAG,IAAA,6CAAwB,EACnD,UAAU,EACV,CAAC,KAAQ,EAAE,EAAE;YAKX,MAAM,WAAW,GAAG,aAAc,CAAC,KAAK,EAAE,CAAC;YAC3C,KAAK,MAAM,MAAM,IAAI,WAAW,EAAE;gBAEhC,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;gBAC1B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAEnB,aAAa,IAAI,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC;aAChD;QACH,CAAC,EACD,GAAG,EAAE;YAGH,OAAO,aAAa,EAAE,MAAM,EAAE;gBAC5B,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,EAAG,CAAC,MAAM,CAAC,CAAC;aAChD;YACD,oBAAoB,EAAE,WAAW,EAAE,CAAC;YACpC,UAAU,CAAC,QAAQ,EAAE,CAAC;YACtB,UAAU,CAAC,WAAW,EAAE,CAAC;QAC3B,CAAC,EAED,SAAS,EAET,GAAG,EAAE,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC,CAC7B,CAAC;QAEF,MAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;AACL,CAAC;AA1FD,gCA0FC","sourcesContent":["import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n"]}},"error":null,"hash":"7b5e759c3d9f221fb03f07292b6395c0","cacheData":{"env":{}}}