{"id":"node_modules/rxjs/src/internal/operators/mergeInternals.ts","dependencies":[{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\tsconfig.json","includedInParent":true,"mtime":1658249596656},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\package.json","includedInParent":true,"mtime":1658249837276},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1658249596644},{"name":"../observable/innerFrom","loc":{"line":4,"column":28,"index":141},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\mergeInternals.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\observable\\innerFrom.ts"},{"name":"../util/executeSchedule","loc":{"line":5,"column":34,"index":204},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\mergeInternals.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\executeSchedule.ts"},{"name":"./OperatorSubscriber","loc":{"line":6,"column":37,"index":270},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\mergeInternals.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\OperatorSubscriber.ts"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mergeInternals = void 0;\r\nconst innerFrom_1 = require(\"../observable/innerFrom\");\r\nconst executeSchedule_1 = require(\"../util/executeSchedule\");\r\nconst OperatorSubscriber_1 = require(\"./OperatorSubscriber\");\r\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\r\n    const buffer = [];\r\n    let active = 0;\r\n    let index = 0;\r\n    let isComplete = false;\r\n    const checkComplete = () => {\r\n        if (isComplete && !buffer.length && !active) {\r\n            subscriber.complete();\r\n        }\r\n    };\r\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\r\n    const doInnerSub = (value) => {\r\n        expand && subscriber.next(value);\r\n        active++;\r\n        let innerComplete = false;\r\n        (0, innerFrom_1.innerFrom)(project(value, index++)).subscribe((0, OperatorSubscriber_1.createOperatorSubscriber)(subscriber, (innerValue) => {\r\n            onBeforeNext?.(innerValue);\r\n            if (expand) {\r\n                outerNext(innerValue);\r\n            }\r\n            else {\r\n                subscriber.next(innerValue);\r\n            }\r\n        }, () => {\r\n            innerComplete = true;\r\n        }, undefined, () => {\r\n            if (innerComplete) {\r\n                try {\r\n                    active--;\r\n                    while (buffer.length && active < concurrent) {\r\n                        const bufferedValue = buffer.shift();\r\n                        if (innerSubScheduler) {\r\n                            (0, executeSchedule_1.executeSchedule)(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\r\n                        }\r\n                        else {\r\n                            doInnerSub(bufferedValue);\r\n                        }\r\n                    }\r\n                    checkComplete();\r\n                }\r\n                catch (err) {\r\n                    subscriber.error(err);\r\n                }\r\n            }\r\n        }));\r\n    };\r\n    source.subscribe((0, OperatorSubscriber_1.createOperatorSubscriber)(subscriber, outerNext, () => {\r\n        isComplete = true;\r\n        checkComplete();\r\n    }));\r\n    return () => {\r\n        additionalFinalizer?.();\r\n    };\r\n}\r\nexports.mergeInternals = mergeInternals;\r\n"},"sourceMaps":{"js":{"version":3,"file":"mergeInternals.js","sourceRoot":"","sources":["node_modules/rxjs/src/internal/operators/mergeInternals.ts"],"names":[],"mappings":";;;AACA,uDAAoD;AAGpD,6DAA0D;AAC1D,6DAAgE;AAehE,SAAgB,cAAc,CAC5B,MAAqB,EACrB,UAAyB,EACzB,OAAwD,EACxD,UAAkB,EAClB,YAAsC,EACtC,MAAgB,EAChB,iBAAiC,EACjC,mBAAgC;IAGhC,MAAM,MAAM,GAAQ,EAAE,CAAC;IAEvB,IAAI,MAAM,GAAG,CAAC,CAAC;IAEf,IAAI,KAAK,GAAG,CAAC,CAAC;IAEd,IAAI,UAAU,GAAG,KAAK,CAAC;IAKvB,MAAM,aAAa,GAAG,GAAG,EAAE;QAIzB,IAAI,UAAU,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE;YAC3C,UAAU,CAAC,QAAQ,EAAE,CAAC;SACvB;IACH,CAAC,CAAC;IAGF,MAAM,SAAS,GAAG,CAAC,KAAQ,EAAE,EAAE,CAAC,CAAC,MAAM,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAE/F,MAAM,UAAU,GAAG,CAAC,KAAQ,EAAE,EAAE;QAI9B,MAAM,IAAI,UAAU,CAAC,IAAI,CAAC,KAAY,CAAC,CAAC;QAIxC,MAAM,EAAE,CAAC;QAKT,IAAI,aAAa,GAAG,KAAK,CAAC;QAG1B,IAAA,qBAAS,EAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,SAAS,CAC1C,IAAA,6CAAwB,EACtB,UAAU,EACV,CAAC,UAAU,EAAE,EAAE;YAGb,YAAY,EAAE,CAAC,UAAU,CAAC,CAAC;YAE3B,IAAI,MAAM,EAAE;gBAGV,SAAS,CAAC,UAAiB,CAAC,CAAC;aAC9B;iBAAM;gBAEL,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aAC7B;QACH,CAAC,EACD,GAAG,EAAE;YAGH,aAAa,GAAG,IAAI,CAAC;QACvB,CAAC,EAED,SAAS,EACT,GAAG,EAAE;YAIH,IAAI,aAAa,EAAE;gBAKjB,IAAI;oBAIF,MAAM,EAAE,CAAC;oBAKT,OAAO,MAAM,CAAC,MAAM,IAAI,MAAM,GAAG,UAAU,EAAE;wBAC3C,MAAM,aAAa,GAAG,MAAM,CAAC,KAAK,EAAG,CAAC;wBAItC,IAAI,iBAAiB,EAAE;4BACrB,IAAA,iCAAe,EAAC,UAAU,EAAE,iBAAiB,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;yBACjF;6BAAM;4BACL,UAAU,CAAC,aAAa,CAAC,CAAC;yBAC3B;qBACF;oBAED,aAAa,EAAE,CAAC;iBACjB;gBAAC,OAAO,GAAG,EAAE;oBACZ,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACvB;aACF;QACH,CAAC,CACF,CACF,CAAC;IACJ,CAAC,CAAC;IAGF,MAAM,CAAC,SAAS,CACd,IAAA,6CAAwB,EAAC,UAAU,EAAE,SAAS,EAAE,GAAG,EAAE;QAEnD,UAAU,GAAG,IAAI,CAAC;QAClB,aAAa,EAAE,CAAC;IAClB,CAAC,CAAC,CACH,CAAC;IAIF,OAAO,GAAG,EAAE;QACV,mBAAmB,EAAE,EAAE,CAAC;IAC1B,CAAC,CAAC;AACJ,CAAC;AAhID,wCAgIC","sourcesContent":["import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n"]}},"error":null,"hash":"f53efe98eb288bb836f86c3f4419d6e2","cacheData":{"env":{}}}