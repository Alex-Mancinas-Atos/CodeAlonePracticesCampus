{"id":"node_modules/rxjs/src/internal/operators/subscribeOn.ts","dependencies":[{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\tsconfig.json","includedInParent":true,"mtime":1658249596656},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\package.json","includedInParent":true,"mtime":1658249837276},{"name":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1658249596644},{"name":"../util/lift","loc":{"line":4,"column":23,"index":133},"parent":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\operators\\subscribeOn.ts","resolved":"C:\\Users\\a875232\\Documents\\rxjs-practice\\node_modules\\rxjs\\src\\internal\\util\\lift.ts"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.subscribeOn = void 0;\r\nconst lift_1 = require(\"../util/lift\");\r\nfunction subscribeOn(scheduler, delay = 0) {\r\n    return (0, lift_1.operate)((source, subscriber) => {\r\n        subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\r\n    });\r\n}\r\nexports.subscribeOn = subscribeOn;\r\n"},"sourceMaps":{"js":{"version":3,"file":"subscribeOn.js","sourceRoot":"","sources":["node_modules/rxjs/src/internal/operators/subscribeOn.ts"],"names":[],"mappings":";;;AACA,uCAAuC;AA6DvC,SAAgB,WAAW,CAAI,SAAwB,EAAE,QAAgB,CAAC;IACxE,OAAO,IAAA,cAAO,EAAC,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE;QACpC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IAChF,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,kCAIC","sourcesContent":["import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n"]}},"error":null,"hash":"9d20d76073d0784fb90961671bd27a7b","cacheData":{"env":{}}}